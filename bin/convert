#!/usr/bin/env node
'use strict';

const webshot = require('webshot')
  , async = require('async')
  , path = require('path')
  , ReactDOMServer = require('react-dom/server')
  , weatherSymbolComponent = require('../index')
  , weatherSymbol = weatherSymbolComponent.create({ fallback: false })
  , recipes = require('../lib/recipes')
  , fs = require('fs')
  , stylus = require('stylus')
  , nunjucks = require('nunjucks');

const dest = process.argv[2] || 'dist/';


function createSymbol (id) {
  return ReactDOMServer.renderToStaticMarkup(
    weatherSymbol({
      type: 'svg',
      id
    }
  ));
}


function createMarkup (svg, env, markupCallback) {
  const stylusFileName = 'src/css/index.styl';
  const stylusCss = fs.readFileSync(stylusFileName).toString();
  const symbolDefs = fs.readFileSync('src/html/symbolDefs.html').toString();

  stylus.render(stylusCss, { filename: stylusFileName }, function (err, symbolsCSS) {
    if (err) throw err;

    var nunjucksCallback = function (err, html) {
      if (err) {
        console.log(err.message);
        throw err.message;
      } else {
        markupCallback(html);
      }
    };

    env.render('svgcontainer.nunjs', { svg, symbolsCSS, symbolDefs }, nunjucksCallback);
  });
}


const options = {
  siteType: 'html',
  windowSize: {
    width: 51,
    height: 51
  }
};


const env = new nunjucks.Environment(new nunjucks.FileSystemLoader('bin/templates'),
                                   { autoescape: false });


async.forEachOfLimit(recipes, 10, function (recipe, id, asyncCallback) {
  const pngFileName = path.join(dest, 'png', id + '.png')
    , svgFileName = path.join(dest, 'svg', id + '.svg');

  const svg = createSymbol(id);

  createMarkup(svg, env, function (html) {
    webshot(html, pngFileName, options, function (err) {
      if (err) {
        console.log(err.message);
        throw err.message;
      } else {
        console.log('Created ' + pngFileName);

        fs.writeFileSync(svgFileName, svg);
        console.log('Created ' + svgFileName);
        asyncCallback();
      }
    });
  });
});
